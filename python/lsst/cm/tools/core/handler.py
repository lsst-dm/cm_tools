from __future__ import annotations

import types
from typing import TYPE_CHECKING, Any, Iterable, Optional

import yaml
from lsst.cm.tools.core.dbid import DbId
from lsst.cm.tools.core.utils import LevelEnum, StatusEnum
from lsst.utils import doImport
from lsst.utils.introspection import get_full_type_name

if TYPE_CHECKING:  # pragma: no cover
    from lsst.cm.tools.core.db_interface import DbInterface, ScriptBase
    from lsst.cm.tools.db.common import CMTable


class Handler:
    """Base class to handle callbacks generated by particular
    database actions.

    Each entry in the database will have an associated
    Handler and configuration file, which will be called
    where particular database actions are taken.
    """

    default_config: dict[str, Any] = {}

    handler_cache: dict[str, Handler] = {}

    def __init__(self) -> None:
        self._config_url: Optional[str] = None
        self._config: dict[str, Any] = {}

    @property
    def config_url(self) -> Optional[str]:
        """Return the url of the file with the handler configuration"""
        return self._config_url

    @staticmethod
    def get_handler(class_name: str, config_url: str) -> Handler:
        """Create and return a handler

        Parameters
        ----------
        class_name : str
            Name of the handler class requested

        config_url : str
            URL to the configuration file for the handler

        Returns
        -------
        handler : Handler
            The requested handler

        Notes
        -----
        There are two layers of caching here.
        1.  A `dict` of Handler objects, keyed by class name
        2.  Each handler caches the config_url to avoid re-reading if
        it has not changed.
        """
        cached_handler = Handler.handler_cache.get(class_name)
        if cached_handler is None:
            handler_class = doImport(class_name)
            if isinstance(handler_class, types.ModuleType):
                raise (TypeError())
            cached_handler = handler_class()
            Handler.handler_cache[class_name] = cached_handler
        cached_handler.update_config(config_url)
        return cached_handler

    @property
    def config(self) -> dict[str, Any]:
        """Return the handler's configuration"""
        return self._config

    def get_handler_class_name(self) -> str:
        """Return this class's full name"""
        return get_full_type_name(self)

    def coll_name_hook(self, level: LevelEnum, insert_fields: dict, **kwargs: Any) -> dict[str, str]:
        """Called to get the name of the input and output collections

        Parameters
        ----------
        level : LevelEnum
            Specify which table we updated

        insert_fields : dict
            Fields used for most recent database insertion,
            can be used in formatting

        Returns
        -------
        coll_names : dict[str, str]
            Names of the input and output collections
        """
        raise NotImplementedError()

    def prepare_script_hook(self, level: LevelEnum, dbi: DbInterface, data: CMTable) -> Optional[ScriptBase]:
        """Called to set up a script need to prepare an entry for execution

        Parameters
        ----------
        level : LevelEnum
            Specify which table we updated

        dbi : DbInterface
            Interface to the database we updated

        data : ???
            Current data for the entry we are preparing

        Returns
        -------
        script_id : int
            The id of the returned script
        """
        raise NotImplementedError()

    def workflow_script_hook(self, dbi: DbInterface, data: CMTable, **kwargs: Any) -> Optional[ScriptBase]:
        """Write the script to run a workflow

        Parameters
        ----------
        dbi : DbInterface
            Interface to the database we updated

        data : ???
            The data associated to this entry

        Returns
        -------
        script_id : int
            The ID of the script
        """
        raise NotImplementedError()

    def check_workflow_status_hook(self, dbi: DbInterface, data: CMTable) -> dict[str, Any]:
        """Check the status of a particular workflow

        Parameters
        ----------
        dbi : DbInterface
            Interface to the database we updated

        data : ???
            The data associated to this entry

        Returns
        -------
        update_fields : dict[str, Any]
            Used to update the status of the workflow in question.
        """
        raise NotImplementedError()

    def collect_script_hook(
        self, level: LevelEnum, dbi: DbInterface, itr: Iterable, data: CMTable
    ) -> Optional[ScriptBase]:
        """Called when all the childern of a particular entry are finished

        Parameters
        ----------
        level : LevelEnum
            Specify which table we updated

        dbi : DbInterface
            Interface to the database we updated

        itr : Iterable
            Iterator over children of the entry we are updating

        data : ???
            The data associated to this entry
        """
        raise NotImplementedError()

    def accept_hook(self, level: LevelEnum, dbi: DbInterface, itr: Iterable, data: CMTable) -> None:
        """Called when a particular entry is accepted

        Parameters
        ----------
        level : LevelEnum
            Specify which table we updated

        dbi : DbInterface
            Interface to the database we updated

        data : ???
            The data associated to this entry
        """
        raise NotImplementedError()

    def reject_hook(self, level: LevelEnum, dbi: DbInterface, data: CMTable) -> None:
        """Called when a particular entry is rejected

        Parameters
        ----------
        level : LevelEnum
            Specify which table we updated

        dbi : DbInterface
            Interface to the database we updated

        data : ???
            The data associated to this entry
        """
        raise NotImplementedError()

    def fake_run_hook(
        self,
        dbi: DbInterface,
        data: CMTable,
        status: StatusEnum = StatusEnum.completed,
    ) -> None:
        """Pretend to run workflows, this is for testing

        Parameters
        ----------
        dbi : DbInterface
            Interface to the database we updated

        data :  ???
            The data associated to this entry

        status: StatusEnum
            Status value to set
        """
        raise NotImplementedError()

    def check_prerequistes(self, dbi: DbInterface, db_id: DbId) -> bool:
        """Check to see if a particular entry is waiting on prerequistes

        Parameters
        ----------
        dbi : DbInterface
            Interface to the database we updated

        db_id : DbId
            Database ID for this entry

        Returns
        -------
        ready : bool
            True if entry is ready
        """
        raise NotImplementedError()

    def _read_config(self, config_url: str) -> None:
        """Utility function to read and cache a configuration from a URL"""
        self._config_url = config_url
        with open(self._config_url, "rt", encoding="utf-8") as config_file:
            self._config = yaml.safe_load(config_file)

    def update_config(self, config_url: str) -> None:
        """Update this handler's configuration by reading a
        yaml configuration file

        Parameters
        ----------
        config_url : str
            The URL of the configuration file
        """
        assert config_url is not None
        if config_url == self._config_url:
            return
        self._read_config(config_url)

    def get_config_var(self, varname: str, default: Any, **kwargs: Any) -> Any:
        """Utility function to get a configuration parameter value

        Parameters
        ----------
        varname : str
            The name of the parameter requested

        default : Any
            The default value of the parameter in question

        Keywords
        --------
        Can be used to override configuration value

        Returns
        -------
        par_value : Any
            The value of the requested parameter

        Notes
        -----
        The resolution order is:
            1. Return the value from the kwargs if it is present there
            2. Return the value from the config if it is present there
            3. Return the provided default value
        """
        return kwargs.get(varname, self.config.get(varname, default))

    @staticmethod
    def get_kwarg_value(key: str, **kwargs: Any) -> Any:
        """Utility function to get a keyword value

        Provides a more useful error message if the keyword is not present

        Parameters
        ----------
        key : str
            The name of the keyword requested

        Returns
        -------
        value : Any
            The value of the request keyword

        Raises
        ------
        KeyError :
            The requested keyword is not present
        """
        value = kwargs.get(key, "__FAIL__")
        if value == "__FAIL__":
            raise KeyError(f"Keyword {key} was not specified in {str(kwargs)}")
        return value

    def resolve_templated_string(self, template_name: str, **kwargs: Any) -> str:
        """Utility function to return a string from a template using kwargs

        Parameters
        ----------
        template_name : str
            The name of the template requested, must be in self.config

        Keywords
        --------
        These can be used in the formating

        Returns
        -------
        value : str
            The formatted string

        Raises
        ------
        KeyError :
            The formatting failed
        """
        template_string = self.config.get(template_name, self.default_config.get(template_name))
        format_vars = self.config.copy()
        format_vars.update(**kwargs)
        try:
            return template_string.format(**format_vars)
        except KeyError as msg:
            raise KeyError(f"Failed to format {template_string} with {str(format_vars)}") from msg

    def resolve_templated_strings(self, template_names: dict[str, str], **kwargs: Any) -> dict[str, Any]:
        """Utility function resolve a list of templated names

        Parameters
        ----------
        template_names : dict[str, str]
            Keys are the output keys, values are he names
            of the template requested, which must be in self.config

        Keywords
        --------
        These can be used in the formating

        Returns
        -------
        values : dict[str, Any]
            The formatted strings

        Raises
        ------
        KeyError :
            The formatting failed
        """
        return {key_: self.resolve_templated_string(val_, **kwargs) for key_, val_ in template_names.items()}
